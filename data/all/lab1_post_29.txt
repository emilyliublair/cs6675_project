Question: 
    Part 3: failing last test case onlyI've managed to make the BIOS call in the bootblock, store the result at a hardcoded address that is known to be unused, read it off that address in the kernel, loop over the array to find the first end address of type 1 in extended memory, and replace the existing PHYSTOP constant with that new value. This allows me to pass all test cases except the last one (test 7), which fails with a timeout/hardfault error, and I'm struggling to understand why. Do we need to do anything beyond simply replacing the constant that's currently being used? Or is there anything else wrong with my approach?lab1

    Student Answer: 
    

    Instructor Answer: 
    > Will the result of the e820 bios call be at the exact destination address specified?If nothing has overwritten it, yes. Keep in mind that since we're in real mode, and the kernel executes in protected mode with paging enabled, the address itself might be different. Also, be aware of the segmentation model in real mode, and how it differs from protected mode.> What is a good strategy for testing/debugging?First, double check that you are using the right addresses. You can step through the do_e820 assembly code if you want to double check where it's storing the data. If the data seems to be disappearing later, maybe it was overwritten by something; you could do a binary search on the flow of execution to figure out where it's being overwritten (i.e., break some time between the call to do_e820 and main(), check whether or not the data has been overwritten, break somewhere else, etc.)Also, just in case, make sure you know what addresses are being used by the bootblock and kernel itself, and place the e820 records somewhere else. Since interrupts are disabled, you have all of the code from the start of the bootblock up to the call to main(), and the flow of execution is pretty simple, so you can check this more or less manually.

    Followup Discussions:
    @103_f1Andrew Boeger3 months agoHow does the Kernel use paging/virtual memory on itself? I'm inside main() with gdb and once kvmalloc runs, gdb can no longer see 0x0. I'm confused on how you would be restricted in main0Rohan Natansh Bafna3 months agoIn entry.S, the kernel turns on paging and sets the page directory to entrypgdir, which sets up the basic scheme of addresses >= 0x80000000 being mapped 1-1 with physical addresses, although only a few pages in that range are mapped before the page mapping is finalized in kvmalloc(). That final page directory doesn't map addresses below 0x80000000 to anything, since those addresses are reserved for user processes.Keep in mind that xv6alwaysuses paging, both for the kernel and for user space.good comment2@103_f2Anonymous Poet3 months agoI solved my specific problem, so if anyone is trying to debug something similar, definitely make sure to be aware of segmentation/addressing in real mode1
    