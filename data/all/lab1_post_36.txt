Question: 
    Conflicting typesIn file includedfrom/usr/include/stdlib.h:32,from/xv6/kernel/src/backtrace.c:4:/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h:209:23: error: conflicting typesfor'size_t'; have'unsigned int'209| typedef __SIZE_TYPE__ size_t;
      |                       ^~~~~~
In file includedfrom/xv6/include/asm/x86.h:5,from/xv6/kernel/src/backtrace.c:1:/xv6/include/types.h:4:25: note: previous declarationof'size_t'withtype'size_t'{aka'long unsigned int'}4| typedef unsigned long   size_t;
      |                         ^~~~~~/xv6/kernel/src/backtrace.c:5:12: error: extra tokens at endof#undef directive [-Werror]5| #undef exit(int)
      |            ^
In file includedfrom/xv6/kernel/src/console.c:11,from/xv6/kernel/src/backtrace.c:6:/xv6/kernel/include/defs.h:106:17: error: conflicting typesfor'exit'; have'void(void)'106|voidexit(void);
      |                 ^~~~
In file includedfrom/xv6/kernel/src/backtrace.c:4:/usr/include/stdlib.h:624:13: note: previous declarationof'exit'withtype'void(int)'624| externvoidexit (int __status) __THROW __attribute__ ((__noreturn__));
      |             ^~~~
cc1: all warnings being treatedaserrors
make[2]: *** [kernel/CMakeFiles/kernelobjs.dir/build.make:146: kernel/CMakeFiles/kernelobjs.dir/src/backtrace.c.o]Error1make[1]: *** [CMakeFiles/Makefile2:304: kernel/CMakeFiles/kernelobjs.dir/all]Error2make: *** [Makefile:91: all]Error2run code snippetVisit Manage Class to disable runnable code snippets×I tried to includestdlib.hto callmalloc()andfree()but I am getting conflict types. Tried toundefthe conflicting types but it didn’t help. Am I not supposed to usestdlib? I saw that there’s amalloc()andfree()inulib.cbut I assume I’m not supposed to use it since that’s for user programs? What should I do instead?lab1

    Student Answer: 
    

    Instructor Answer: 
    Changing the mode of execution can't easily be undone, but nothing about the jumps is "non-returnable". The BIOS still exists when you call the bootloader, and the bootloader still exists when you run the kernel. The BIOS won't be overwritten (it's memory mapped to a ROM chip), but eventually when the kernel runs it'll probably overwrite the bootloader (although since the bootloader runs in low memory, I doubt this happens in xv6).In particular, in the part of the bootloader that runs in real mode, nothing is stopping you from jumping back into the BIOS if you wanted. Although, the typical mechanism to make a BIOS call is to use an interrupt,which is exactly what do_e820 does if you check the disassembly. The BIOS has set up the interrupt vector table to point execution back to the BIOS when an interrupt happens, and one of these vectors is used by bootloaders to call back into the BIOS. (In fact, the BIOS's original purpose was to act as a sort of manufacturer-provided library so that OSs like DOS could portably perform I/O tasks across different types of machines; this is where the name Basic Input/Output System comes from.)

    Followup Discussions:
    @93_f1Andrew Boeger3 months agoAwesome, thank you for the detailed response!0
    