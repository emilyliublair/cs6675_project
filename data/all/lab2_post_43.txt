Question: 
    Virtual Memory IncreasingDuring bootup I see that for init the guard page is at x0000 - x1000 and then the stack is x1000 - x2000. For shell I see that the virtual address of the guard page is x1000 - x2000 and the stack is x2000 - x3000. Why is virtual memory increasing like this for different processes? The stack pointer for init is x3000 and x4000 for shell. I am not sure how the stack pointer gets increased like this before the processes have any chance to request memory my understanding was that in exec sz should be x1000 and then incremented to 3000 after two page allocations.Also it looks like we have extra page zeros not sure if we should have PGZERO 0x0, 0x1000, 0x3000 after the first time.lab2

    Student Answer: 
    

    Instructor Answer: 
    

    Followup Discussions:
    @261_f1Anonymous Helix2 months agojust out of curiosity, which two tests were you passing?0Anonymous Atom2 months ago1 and 5. Wasn't able to pass more test cases after fixing this problem though.Any tips on how to pass 2-4 and 6-8?0Anonymous Helix2 months agoI don't remember what correlates with what but I remember killing process's for when things shouldn't be happening (i.e. faults on reads, if the PDE doesn't have it's present bit, etc.). Really just think about your error handling. and in allocuvm, think about what should be mapped to the zero page and what should be just allocated right away if you haven't already. making sure usertests still passed (other than mem() and preempt()) after implementing COW and lazy zero helped us with some other test cases also.1Tianyi Yu2 months agoI think I passed 9-13 after fixing what you were talking about… 2-4 and 6-8 seem to be more about just regular cases. I know for sure that 9 is testing sbrking until kalloc can’t spit out any more memory (cuz I happened to forget to release the lock upon kalloc fail and I only failed #9)1Ranjani Rajeswari Koushik2 months agoCan you expand on what particular situation where in allocuvm you would create a new page immedietly rather than map it?0Tianyi Yu2 months agoData/text page and user stack pages only. These should be allocated in exec.c3Anonymous Helix2 months agoyes my bad, you would think about it in exec.c.i worded that incorrectly in my original response3Ranjani Rajeswari Koushik2 months agosolved my problem, thanks!2Tianyi Yu2 months agoniiiiice!0Shourik Banerjee2 months agoCan you explain what you mean with error handling with reads? I'm pretty sure mine is breaking on the read in fourfiles in user.c0Anonymous Helix2 months agoI just meant that you kill the process if the page fault happens because of a read0Shourik Banerjee2 months agoWhat are you supposed to do if you page fault because of a read? My understanding was we kill it if it's not a write.0Anonymous Helix2 months agoYes I believe you're right. We kill if it's not a write0Shourik Banerjee2 months agoHmm, my code seems to fail on this line of fourfiles (around line 566 of usertests.c)while((n = read(fd, buf, sizeof(buf))) > 0){So I'm pretty sure it's an issue with the read, but I can't figure out what, because it gives me the unexpected trap 14 panic.0
    