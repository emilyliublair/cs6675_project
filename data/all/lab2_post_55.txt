Question: 
    Invalid OpcodeI'm getting traps for invalid opcode. Has anyone encountered this before? Does anyone know what might be causing this?lab2

    Student Answer: 
    

    Instructor Answer: 
    How can you get around this?What real world OSs do is swap to disk to gain a larger pool of memory to use, and if that fails as well (if the swap space is filled or there is no swap space to begin with), they will start killing processes to free up memory. Look up the OOM killer on Linux if you’re interested.For your lab 2 implementation, your existing approach is correct. Don’t check whether you have enough physical memory to back the copied zero page during malloc() or sbrk(); as you said, it defeats the point of lazy zero page allocation.

    Followup Discussions:
    @241_f1Anonymous Helix2 months agoFor your lab 2 implementation, your existing approach is correct.
Does this not change binary compatibility then? Before, malloc() would fail in the code flow before the process would get killed. Now, the process will get killed resulting in a difference in behavior.This also means that the mem test provided in usertests.c will no longer pass. Is this the desired behaviour?0Rohan Natansh Bafna2 months agoYou’re right that it does technically break binary compatibility, but out of memory failures is something of an exception to that rule. Killing the process is the expected behavior.good comment0
    