Question: 
    Malloc never fails which defeats the point of lazy page allocation and COWI am trying to pass the mem test provided in usertests.c. This test case attempts to keep requesting more memory with malloc until the system runs out. When you call malloc, because we have lazy allocation, malloc returns without errors and just gives the address of the zero page (since it uses sbrk under the hood).If you try writing to this page (which is COW), there will be a page fault which allocates a new physical page, so everything resumes as normal. However, if there is no physical memory left, the COW will fail and the page trap handler will need to kill the process.This changes the behavior of user space allocators like malloc. Before, malloc would fail if the user requested memory but the system did not have any.  However, now malloc will not fail since it always gets what it wants (as long as the requested number will keep its va < KERNBASE). The process will instead exit() once physical memory is depleted when handeling COW related page faults.How can you get around this? If you check beforehand that there is enough memory to back up malloc’s or sbrk’s requests, does that not make lazy allocation useless? (since you will not be able to allocate more virtual pages than physical frames to back them up).lab2

    Student Answer: 
    

    Instructor Answer: 
    I think lapicinit() needs to have been called first for the APIC calls to succeed.Looping through the parent’s page table and mapping every entry would be a more robust solution, but for simplicity xv6 is designed to always map the virtual addresses [0, sz) and nothing else.Yes; you can look atforktest_expected_cow.outandforktest_expected_complete.outto see the what values you should be passing in are.We don’t provide a copy of the ELF file that forktest uses so you would have to step instruction by instruction using thesicommand. It might be easier to instead set a breakpoint attrap()to capture all the ways in which the user program interacts with the kernel (by syscalls or page faults) as that is usually what matters most in this lab.

    Followup Discussions:
    @240_f1Anonymous Poet2 months agoFor 1 I tried calling lapicinit() before kinit1() but I am still stuck at the same place with the same error.For 3 I know what the expected values are from forktest_expected_cow.out, but when I break inside my page fault handler, I can't find the correct address by looking at all of the register values, the trap frame, myproc(), or mycpu().0Rohan Natansh Bafna2 months agoI think you also need mpinit() to be called first. I honestly recommend just initializing the locks near the end of main(); for instance kalloc and kfree only start using locks once kinit2() has been called.The CR2 register holds the faulting virtual address on a page fault.good comment1Anonymous Poet2 months ago3: I am ''
PGTRAP: err: 0x7, va = 0x2f6c
PGCOPY: 0x2000
PGTRAP: err: 0x7, va = 0x2f60pgtrap prints out the faulting virtual address (value in cr2) but it is different from the virtual address that pgcopy prints. I can't find the value 0x2000 in anywhere.0Rohan Natansh Bafna2 months agoJust round the addresses down to the nearest page-aligned address. (Use thePGROUNDDOWNmacro)good comment1
    