Question: 
    Log Merge AtomicitySo let's say we get to the end of log merge and we now want to clear the log. We want to do this atomically to ensure crash consistency, so we can invalidate everything in the log by invalidating the very first commit in the log. In lecture 23, we discussed writing garbage 0's to the checksum/commit, but why is this atomic? Is it because, as soon as we write anything, the checksum would no longer match the entry, making it act as a boolean?midterm

    Student Answer: 
    This seems correct to me, however, I believe we do not expose flush to the user. Instead, what the user has access to is fsync().

    Instructor Answer: 
    no, that's not entirely correct, especially your last bullet.The point of the last 3 lectures IS, in fact, to ensure atomicity if/when faced with a crash at any give point during disk operations. Remember that atomicity means that we either persist the entire entry or none of it. Logging and shadowing give us the ordering and atomicity that ensures crash consistency.The first part is correct. Your interface to the disk is a block read, block write, and a flush. Block operations can be reordered, unless there's a flush. Flush ensures that all pending block writes persist to disk. Then we need to correct the rest of your first bullet point. We don't expose this interface to the user.

    Followup Discussions:
    1 endorsed followup comment@726_f1Varoon Sai Kodithala3 days agoAh, I see. This makes sense. My question was more around what's given to us by the disk firmware itself. To clarify, the firmware itself doesn't provide any notion of atomicity or ordering. This is implemented by us, the user, via logging and shadowing.~ An instructor (Alexey Tumanov) thinks this is a good comment ~1Alexey Tumanov3 days agoyes, that's right. We ( i.e. the kernel FS and, separately, a POSIX application) implements crash consistency on top of the disk interface which has neither atomicity nor ordering.good comment1Varoon Sai Kodithala3 days agoThank you!0
    