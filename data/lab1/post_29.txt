Question: 
    finding memory from e820 callFor part 3 of lab 1, I have tried to call do_e820 in bootasm.s with a destination address specified. However I when I check if there is data at that address using xp in the qemu monitor and x in gdb (but maybe this is just for virtual addresses?) once a breakpoint at the beginning of main hits, everything seems to be set to 0 no matter what I do.Will the result of the e820 bios call be at the exact destination address specified? Or am I looking for it too late in the kernel startup? What is a good strategy for testing/debugging?lab1

    Student Answer: 
    

    Instructor Answer: 
    > Will the result of the e820 bios call be at the exact destination address specified?If nothing has overwritten it, yes. Keep in mind that since we're in real mode, and the kernel executes in protected mode with paging enabled, the address itself might be different. Also, be aware of the segmentation model in real mode, and how it differs from protected mode.> What is a good strategy for testing/debugging?First, double check that you are using the right addresses. You can step through the do_e820 assembly code if you want to double check where it's storing the data. If the data seems to be disappearing later, maybe it was overwritten by something; you could do a binary search on the flow of execution to figure out where it's being overwritten (i.e., break some time between the call to do_e820 and main(), check whether or not the data has been overwritten, break somewhere else, etc.)Also, just in case, make sure you know what addresses are being used by the bootblock and kernel itself, and place the e820 records somewhere else. Since interrupts are disabled, you have all of the code from the start of the bootblock up to the call to main(), and the flow of execution is pretty simple, so you can check this more or less manually.

    Followup Discussions:
    @103_f1Andrew Boeger2 months agoHow does the Kernel use paging/virtual memory on itself? I'm inside main() with gdb and once kvmalloc runs, gdb can no longer see 0x0. I'm confused on how you would be restricted in main0Rohan Natansh Bafna2 months agoIn entry.S, the kernel turns on paging and sets the page directory to entrypgdir, which sets up the basic scheme of addresses >= 0x80000000 being mapped 1-1 with physical addresses, although only a few pages in that range are mapped before the page mapping is finalized in kvmalloc(). That final page directory doesn't map addresses below 0x80000000 to anything, since those addresses are reserved for user processes.Keep in mind that xv6alwaysuses paging, both for the kernel and for user space.good comment2@103_f2Anonymous Poet2 months agoI solved my specific problem, so if anyone is trying to debug something similar, definitely make sure to be aware of segmentation/addressing in real mode1
    