Question: 
    

    Student Answer: 
    

    Instructor Answer: 
    How have you debugged so far? Note that a solution that runs is not the same as a solution that’s correct. The AG scans stdout to determine whether the backtrace output is correct. Which means everything that’s being printed out needs to be correct down to the character.I would suggest placing calls to backtrace in a few places throughout the kernel and validating if the output makes sense. Start with kernel’smain()and then continue through any other functions that call it. You can also place it in a syscall and write a user program that makes a call to that syscall. Based on what you already know and the xv6 manual, ask yourself, does the output you’re seeing make sense? Additionally make sure your formatting is 100% correct because this causes issues often in this lab.

    Followup Discussions:
    @83_f1Rohan Natansh Bafna2 months agoIn what situations have you run your backtrace function? There are multiple entry points to the kernel; _start is one, when the first CPU of the system boots up, but there are other ways in which execution can enter kernel space. Have you tested against them all?(oops, this was supposed to be an answer lol)good comment0Anonymous Gear2 months agoI've been using system calls and as far as I can tell, the output looks reasonable.Putting backtrace() in kernel main() panics on a user return address with the last values being:ebp = 0x801380d8Return Address = 0x0The ebp value seems valid so I'm not sure how to handle this correctly0Rohan Natansh Bafna2 months agoI would suggest using gdb to figure out what's going on. Set a breakpoint at the beginning of backtrace, and double check the values of ebp and the return addresses you see as you walk the stack with the contents of the stack itself. You'll find thexcommandparticularly helpful; it dumps a region of memory as raw bytes to the console.You can also cross reference your findings with the disassembly of the xv6 kernel at build/kernel/kernel.asm to see what exact instructions are executed at the beginning of main and at the beginning of backtrace that would set up the stack.good comment2Anonymous Helix2 months agoI am also dealing with the exact same issue now. :(0@83_f2Shourik Banerjee2 months agoHow can I understand if my output makes sense or not? The names I get match up and I don't know if there's any way for me to tell if the offsets are correct or if the return addresses I'm getting are correct. I'm also pretty sure that my output format is correct.Inside the mpmain function, the output of backtrace is:<0x801043ed> mpmain+12<0x801043c7> mpenter+00Rohan Natansh Bafna2 months agoYou can check the addresses against the disassembled kernel at build/kernel/kernel.asm; you should see a call instruction at each location you print, within the right function.good comment0Shourik Banerjee2 months agoIs the address I want the start of this line?8010441f:    e8 9f c9 ff ff           call   80100dc3 <backtrace>I seem to be getting the address of this line, where it refers to the call right after the previous line.80104424:    e8 0e 09 00 00           call   80104d37 <cpuid>I just want to make sure that I want the address from the <backtrace> line instead of the one after it, or if the one after it is actually the one I want.EDIT:Never mind, my issue was not printing the line "Backtrace\n" at the start.1Anonymous Poet2 months agoSo in this case, the address that you are printing is 0x80104424 right?0
    