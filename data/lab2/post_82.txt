Question: 
    Returning to user mode from trapUpon returning from a trap, I know the trapret block of code in trapasm.S is run, and iret is used to return to user mode. How is iret different from ret? Does it still use the value stored under ebp in the stack as the return address? If I were copying pages incorrectly, how could this cause iret to return to uninitialized memory (all set to 0x0)?lab2

    Student Answer: 
    

    Instructor Answer: 
    How is iret different from ret?I know this is a bit of a cop-out answer, but if you have questions like this about the x86 architecture, readthe manual, it has all of this info and more :)Here’s the (first page of) the section on IRET.It’s a lot, but the relevant part to your question is here:As with a real-address mode interrupt return, the IRET instruction pops the return instruction pointer, return code
segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then
resumes execution of the interrupted program or procedure. If the return is to another privilege level, the IRET
instruction also pops the stack pointer and SS from the stack, before resuming program execution.Note that the stack frame layout for IRET is slightly different compared to a regular function call, because this is a hardware-generated call and doesn’t follow our (software-based) calling convention. In particular, we don’t push or set%ebpanywhere.If I were copying pages incorrectly, how could this cause iret to return to uninitialized memory (all set to 0x0)?Do you mean the return address is 0x0? YSK that this is entirely possible in normal circumstances; xv6 maps the 0th virtual page in userspace processes and frequently main() is placed at virtual address 0, so the entry point of some userspace binaries IS 0x0. You can double check this yourself by looking at the output ofreadelfon whatever binary you are exec’ing. Since exec sets the return address of a process to the ELF entry point, the first time the kernel returns to that process, it will return to the entry point.So returning to address 0x0 is not necessarily indicative of a bug. And I doubt it would be a bug in your implementation, since all this happens at the kernel level, and shouldn’t be affected by your changes to the userspace half of the address space.

    Followup Discussions:
    @198_f1Anonymous Poet2 months agoThe exact return address is actually 0x100, and the memory is all 0s at this location (I know because it does the add instructions until it tries to access a page without permission at 0x1000).0Rohan Natansh Bafna2 months agoGotcha, sorry for the misunderstanding. Should there be actual code at 0x100, or is it supposed to be filled with 0s? Check the disassembly of whatever user program you were trying to run and see if there are instructions located there.If there are supposed to be instructions there (so the return address is probably right), then something may have gone wrong when you loaded the program into memory. Exec calls loaduvm to copy program code into memory; maybe you should set a breakpoint there, and walk through the code, taking note of where (in what physical pages) it’s writing the program segments to. Check if that seems correct, and if the page mappings are the same when you page fault. Also double check that you invalidate your TLB entries properlygood comment1Anonymous Poet2 months agoThanks for the debugging tips, I’ll get to it!0
    