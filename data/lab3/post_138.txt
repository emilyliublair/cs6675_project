Question: 
    Can I kalloc space for a thread group lock?or will the kalloc mess up behavior of the testcases?The current conundrum:can't include spinlock in proc struct due to circular dependenciesvs.suspecting that kallocing for the spinlock in proc.c has changed the behavior of the test caseReasons for suspicion:I have a submission passing everything except #31, which failed because of the thread group lock issue. I then added a spinlock pointer in the proc struct and found I couldn't initialize it in allocproc without shell crashing, so I had to kalloc out the space for the pointer and then initialize the lock. I then added just acquire and release statements for the lock in respective files. After this, the submission passes everything except #25, which is an incorrect output. Considering that if I made a mistake in acquiring and releasing the locks, it would likely end up in a deadlock, I believe the kalloc is the only thing I changed in my implementation that may cause an incorrect output. I have checked the diffs of the files to make sure all implementation changes were listed above.lab3

    Student Answer: 
    The answer is no, you can't.I resolved the circular dependencies to not kalloc space for the lock, which passed the autograder.

    Instructor Answer: 
    

    Followup Discussions:
    @345_f1Anonymous Helix4 weeks agoHow did you end up solving this without kallocing a lock and using that pointer for every thread in the thread group? If I have a spin lock directly in the proc struct (not a pointer) and I copy it when cloning, that won't be a reference to the same lock as the parent in the child thread right?0@345_f2Anonymous Comp3 weeks agoWhy cant you include a spinlock in the proc struct? we did that and it worked fine...0Anonymous Helix3 weeks agoI could be wrong but I'm pretty sure if you include a struct spinlock in proc struct and then try to copy that to another proc struct when cloning, you wouldn't actually be copying the same struct, so there would still be concurrency issues within the thread group. I'm thinking you have to store a (struct spinlock *) but not sure where to initialize the spin lock without kalloc()ing space for it.0Anonymous Comp3 weeks agook cool.why not just store a reference to the threadgroup leader in all processes (threadgroup leader can point to itself)then you can always reference the threadgroup leader's singular lock by referenceexample:structproc{structproc*group_leader;structspinlock;}run code snippetVisit Manage Class to disable runnable code snippetsÃ—access with p->group_leader->spinlock;On clone the group leader reference gets copied so the underlying spinlock is the same.1
    