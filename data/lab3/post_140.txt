Question: 
    

    Student Answer: 
    I have passed #31 by implementing locks for thread actions that should be reflected throughout the thread group.

    Instructor Answer: 
    

    Followup Discussions:
    @343_f1Tianyi Yu2 months agoHere are some things I have done:I've checked that updates to variables in one thread are shown to everyone in the thread groupI've checked that recursive cloning worksI've checked that all critical sections regarding file systems, cwds, or size changes are protected by a lock shared among the thread groupI've checked that pipe works particularly as it involves sleep (so I regain the shared lock after sleeping)I've checked that other processes are not able to access variables not in their thread groups0Tianyi Yu2 months agoI tried sbrking until fail in multiple cloned threads in the same thread group, and I realized that one process hitting the limit would cause it to exit, and in deallocuvm there would be kfree, which frees out one page for kalloc. Thus, I was able to have some other processes continue to get a few pages before allocuvm runs out of memory. Is this expected?0Tianyi Yu2 months agoGreat now I passed Test #31 at the expense of Test #25...0Rohan Natansh Bafna2 months agoI tried sbrking until fail in multiple cloned threads in the same thread group, and I realized that one process hitting the limit would cause it to exit, and in deallocuvm there would be kfree, which frees out one page for kalloc. Thus, I was able to have some other processes continue to get a few pages before allocuvm runs out of memory. Is this expected?If a process runs out of memory, then sbrk() should return -1. It shouldn’t kill the process, so no, that’s not expected.good comment1Tianyi Yu2 months agoHi Rohan, I got this question solved and passed #31 both with and without this behavior. I am not killing any processes, it's just that when a process naturally exists, its kstack is freed. Right now, I am failing #25, and I'm trying to test for it comprehensively. If you could help me look into it that would also be great!0Tianyi Yu2 months agoRohan, I figured out the problem for test #25. I was kallocing for the thread group lock, which messed up the behavior of the test cases. Thank you for your help along the way! (Also, a huge thanks to all those TAs I pestered during office hours!!)2Joshua Patrick Forden4 weeks agoDid you end up allocating a page with kallloc() for the thread group lock? This seems to be the best way to ensure that the entire thread group can have a pointer to the lock, but I'm running into some bugs and deadlocking so I'm not sure.edit:@3450@343_f2Anonymous Calc1 month agoI'm stuck figuring out what thread actions need to be locked for. Do syscalls that modify the file system need to be under a lock or can they be allowed to run without locks.0Tianyi Yu1 month agoit shouldn’t be locked on the syscall level, but all threads should acquire a lock for file system modifications1Anonymous Calc1 month agoAs in any syscall that may modify the thread groups ofile, cwd, or pgdir should require a lock at some point?0Tianyi Yu1 month agoYes0@343_f3Anonymous Atom3 weeks agoWas anyone able to resolve test case 31 without implementing locks. It seems that it is possible to pass all autograder tests without locking thread groups.0
    