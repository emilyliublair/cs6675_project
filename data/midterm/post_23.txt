Question: 
    

    Student Answer: 
    I could be wrong but I believe the directory inode just contains 13 struct dirents stored directly in the inode in the slots where a file inode would have the 13 (12+1) data block/indirect pointers. The reason there’s only 13 of them is so it’s the same size/layout for the directory inodes as the file inodes. It is pretty restrictive.Also I hope they get sound for the recording I had the same issue today!

    Instructor Answer: 
    

    Followup Discussions:
    @714_f1Sebastian Tyler Morgenstern4 days agoThanks to whoever replied, but I'm pretty sure that's not the case (maybe I'm wrong though!). Consider that each dirent is 16 bytes (14 bytes for the name + 2 bytes for the inode num). If there are 13, that is 16*13=208B which is well over what's allocated for inodes (64B).I think instead directories have a pointer to a data block on disk which stores the array of dirents? It wasn't immediately clear to me looking over the slides and in lecture that's why I was a bit confused. Let me know if anything there is wrongI found this image (and a few like it) that seem to support this:Note that the first data block of the directory inode points to the dirent block1Anonymous Comp4 days agoYou are right, looking back at the code it definitely seems like the dirents are being read from disk. Tracing calls from some function like dirlookup that uses the dirents takes you through readi, bread, bmap. Looking through that code right now is helping me piece together the dirent access, and yeah it is eventually getting a data block location from the inode’s addrs array.1Sebastian Tyler Morgenstern4 days agoCool! Let me know if you find anything about why it's capped at 13, I just want to make sure I'm not missing anything like extra overhead or something that might be limiting it0Anonymous Comp4 days agoActually, I don’t think anything explicitly limits the number of dirents in a directory other than just the maximum file size / the size of dirent struct. this would lead to about 4000 possible dirents in a directory. This is reflected in the for-loop conditions of the screenshot below which is fromdirlookupinfs.c. It seems like we can change the size of the directory similarly to the size of other files, and access data in the same way, so long as we recognize that data will be in the form of dirent structs.In short I think the slide might be wrong… This would be worth bringing up in class for sure.0Sebastian Tyler Morgenstern4 days agoYeah that's what I was confused about... I think instead of 4000 it'd be closer to 384 considering there are normally 12 pointers to data blocks in a normal inode, so 12*32, where 32 is the number of dirents you could fit in a 512B block. I guess if we really needed a lot of files in a directory and wanted to keep the inode structure we could get like (12+128)*32 by using an indirect pointer.The way it seems to be outlined is it just uses the first direct pointer to a block though, so I was just asking here to verify that this is how dirents are stored AND was wondering if there was a design decision or reason why xv6 caps at 13, since 13 (12+1) is also (confusingly) the number of address pointer attributes dedicated in a file inode structure, so it'd be really easy to confuse a dirent as being stored as a part of the directory inode instead of in a block pointed to by the dir inode.0
    