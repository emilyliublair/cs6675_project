Question: 
    

    Student Answer: 
    I don’t have a 100% solid answer but I think this could explain it:I think technically you could do group commits without using checksum, but it would not be a great practice: You would have to do something like {e1, e2, e3} -> flush -> {c123} -> flush, etc. when writing. This does decrease flushes per entry, but not to the point where it would be very useful.  And then upon recovery or reading back the log, we could find ourselves in a situation where e1 and e3 are fully valid but e2 is not, so c123 is not set and thus we have to disregard all 3 entries. The only way to significantly increase the efficiency would be to increase the number of entries that share a commit bit, but this makes the recovery way less effective: what if we had 100 entries sharing a commit bit, and 99 are valid but one isn’t? We would not be able to use any of those writes, and all that effort would have been wasted.With checksum, we can commit a group all at once where each has its own checksum (easy to do because we don’t need flushes). Then each still has its own mechanism for determining its validity.

    Instructor Answer: 
    

    Followup Discussions:
    @735_f1Anonymous Gear1 day agoCan I also add to this post and ask why checksum implementations mean that a flush is not required between an entry and a commit? I'm not sure if I understood it from lecture.0Anonymous Poet1 day agoWhen developing a logging system we want some way to be sure that we can tell whether an entry was done completely or not. A commit bit and a flush ensures this because if we see the commit bit is high, we know the flush has been completed, as the commit is only set after a flush. This establishes a happens-before relationship, making us sure that the data component of the entry was already completed, as it goes {entry -> flush -> commit}.So in a checksum log we want the same thing: to have some indication that we can be sure the entry is valid. Your concern is that without a flush, we can’t be sure of the happens-before relationship, which is true: it’s possible that the checksum is written to log before the entry is written completely. However, when we read this log entry to decide whether to use it, we can tell whether the entry is fully complete: if f(entry) = checksum, we basically know that it’s what was meant to be written, where as if f(entry) != checksum, we know that something is wrong. (f here is the checksum function). So if the checksum is written first, and then the OS looks through the log and wants to know whether that entry is valid, it will compute f(entry) and see that it does not equal checksum, and will consider it invalid.4@735_f2Anonymous Scale1 day agoSo for the second question, if the checksum is written to disk first, then its corresponding entry’s checksum is not equal to the new checksum, therefore it’s invalid and will be ignored. On the other hand, if the entry was written first, then old checksum would not also not correspond to the current entry, so it’s invalid.The only way it would be valid is if both the entry and checksum correspond to each other, which makes the transaction atomic without flushes, which is why it’s so much better than normal commits.0
    