Question: 
    Class tomorrowWill class be virtual tomorrow or will the lecture be recorded?logistics

    Student Answer: 
    According to the schedule there is no class tomorrow for Section C:https://github.gatech.edu/pages/cs3210-spring2025/course/schedule/~ An instructor (Alexey Tumanov) endorsed this answer ~

    Instructor Answer: 
    Try usinghttps://github.com/rizsotto/Bearalong with clangd to generate a compile_commands.json. You'll need to re-generate compile_commands.json each time you edit kernel/Sources.cmake or user/Sources.cmake, though :/(Edit: you'll need to use this in conjunction with clangd.)Edit from Rohan:According to the clangd docs, you can generate compile_commands.json automatically without Bear if you add-DCMAKE_EXPORT_COMPILE_COMMANDS=1to the cmake configure command.

    Followup Discussions:
    @67_f1Mrinal Jain3 months agoI'm also using clangd with Neovim. The issue I have is that since I'm running cmake inside the docker, all the paths in the exported compile_commands are relative to the docker, and so clangd shows errors.0Ved Thiru3 months agoTry running cmake outside the docker image.good comment0Mrinal Jain3 months agoThenmakedoesnâ€™t work inside the container, and so every time I want to run xv6 have to delete the contents of the build directrory and run cmake again from inside the docker.0Mrinal Jain3 months agoThe solution that worked for me was to create 2 separate build folders,buildanddocker_build. I run cmake on my local machine inside thebuilddirectory, and so my LSP works perfectly including jumping to definitions. For actually running xv6 inside Docker I run cmake and make from thedocker_builddirectory from inside the container.0Anonymous Poet3 months agoThis worked. Thanks0@67_f2Richard Alexander Barrezueta3 months agoHere is how my compile_commands.json looks like. It's been working for me, but there's been some cases where I needed to place some #ifndef when xv6 includes <atomicstd.h>.In the json file, change `directory` to point to where xv6 is located. Also, place it where clangd can see it. For me, it's in the same directory as .git.I will say that this is like a bandaid, since it doesn't automatically jump to function definitions without opening the file with the function definition to begin with, so I just use telescope to find the definition for now. But it does resolve all the #includes in the file.[{"arguments": ["/usr/bin/gcc","-I./include","-I./kernel/include","-I./user/include","-fno-strict-aliasing","-Wall","-ggdb","-fno-omit-frame-pointer","-fno-stack-protector","-fno-builtin","-fno-pic","-m32","-O2","-DNDEBUG","-std=gnu11","-c","-o","./CMakeFiles/kernelobjs.dir/src/mp.c.o","./kernel/src/mp.c"],"directory": "/path/to/xv6","file": "./kernel/src/mp.c","output": "./kernel/CMakeFiles/kernelobjs.dir/src/mp.o"}]2
    