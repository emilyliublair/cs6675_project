Question: 
    Autograder Test Cases 2-4 & 6-8I can’t pass the test cases mentioned above. I have done both parts 1 and 2. My kernel seems to be stable but only scores 7/13 on the autograder (no hard faults).I have written manual test cases such as forking child + grandchild (and checking page copying when any page is written to), exiting parent before child, malloc until process gets killed, trying to access memory outside user space from a user context, accessing unallocated memory.I still can not get these test cases working. What other edge cases should I consider? I haven’t been able to get the system to break on my end. I read the other post about trying to think like a hacker / finding exploits.Any tips?lab2

    Student Answer: 
    

    Instructor Answer: 
    

    Followup Discussions:
    @247_f1Shourik Banerjee2 months agoI don't know if it's trap.c, but if I switch back to the default allocuvm.c implementation it is able to boot properly. So I think the issue is either with how I handle a special flag for the zero page called PTE_ZERO which I set for it, and unset when it gets copied (so only page number 57210, my zero page has this flag), or it's in how I allocuvm.0Tianyi Yu2 months agoWhy would you unset PTE_ZERO when it gets copied? Wouldn't you only unset the Copy-on-write reference? I think you would only want to unset PTE_ZERO if you're allocating a new page for a zero page that was written to. It should be a different criterion from getting forked.0Shourik Banerjee2 months agoSorry, that's what I meant. When the new page gets created for it (so when it is written to), that's when PTE_ZERO gets unset.0Tianyi Yu2 months agoDid you flush the TLB entry after that Trap error 7, va = 0xff? It seems that right now your 0xff is still unmapped (error code 0->not present)0Shourik Banerjee2 months agoYes, in my handler after every page fault I flush the TLB using the address given to me by rcr2()0Tianyi Yu2 months agoCheck if you’re updating the PTE correctly since it’s definitely not getting reflected in the user process. Error code 0 means the page is unmapped, so check if the permissions you gave for the new page is correct. Make sure that the PTE_P is turned on.0Shourik Banerjee2 months agoUsing GDB, I found that even when I got a trap of 0, the permissions were that of a 0 page. The page num is also that of the zero page. The zero bit is on, and it is mapped. I have no idea where this is getting changed, especially considering that 0 means the page should be unmapped but the pte I get says it is mapped? I am confident that the pte I am getting is correct too considering I use walkpgdir to get the pte from the faulting virtual address.0Tianyi Yu2 months agoMaybe you aren’t dereferencing the pte pointer when changing the permission? You should be changing *pte and not pte. (just a guess)0Shourik Banerjee2 months agoUnfortunately not the case, thanks for trying help though. I'll see if I can get it resolved in OH tomorrow.1@247_f2Shourik Banerjee2 months agoI figured it out. Turns out, you're not supposed to lazy zero the code and data part with allocuvm.2Tianyi Yu2 months agoThat's great! Just a hint, you're not supposed to do that with the stack page either.0Shourik Banerjee2 months agoYeah I saw that in another Piazza post, just mentioned the data part because that was the part that was breaking it while I'm pretty sure the stack page just makes it less efficient.1
    