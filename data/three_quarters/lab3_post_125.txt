Question: 
    Thread Exclusion Promises does the kernel make with regard to threadsIs it the kernel's job to ensure exclusion when making changes to the pgdir for example? In lab I was told that when two processes are writing to the same file it can interleave, so what is and is not allowed to overlap with regard to the shared resources.lab3

    Student Answer: 
    

    Instructor Answer: 
    

    Followup Discussions:
    @374_f1Richard Alexander Barrezueta1 month agoI think 9 has to do with when you lower the current running process’ priority, whether it preempts to another process that now has a higher priority to it.0Anonymous Mouse1 month agoweird, if all the processes in the ptable are RR, wouldnt this cause the currently executing process to be stopped in favor of the next in line for RR?0Varoon Sai Kodithala1 month agoWell, it depends on their priorities. If we just lowered the priority of a process and there's a process with a higher priority with the RUNNABLE flag set in the ptable, then we should schedule that process. If there's no process with a strictly greater priority in the ptable, then we continue on with our current process.0Anonymous Mouse1 month agoDosent RR always wana schedule next next process on a yield() though?0Richard Alexander Barrezueta1 month agoAlso you only consider RR if equal highest priorities (and assuming there are no FIFO. FIFO always have higher priority than any RR).So schedule based on priority first, then policy if equal priorities.0Anonymous Calc1 month agoSo schedule based on priority first, then policy if equal priorities.Wait, what do you mean by this? I thought FIFO will always get scheduled before RR?0Anonymous Mouse1 month agoLets say that you have a bunch of processes which are all RR and an index which keeps track of the current RR process running.Then, far away from the index, a process turns into FIFO and takes control. Where does the RR pick up from? Does it continue from the new spot or does it fall back to where it used to be?1Anonymous Calc1 month agoohh ok i see what you mean, thank you0Richard Alexander Barrezueta1 month agoHere’s some examples, since it’s kinda hard to explain without:FIFO priority 1 > RR priority 50FIFO priority 2 > FIFO priority 1RR priority 1 (arrived first) > RR priority 1 (arrived later)FIFO priority 1 (arrived first) > FIFO priority 1 (arrived later)New RR appends to end of sub-queue of same prorities, similar to FIFO.The only difference between RR and FIFO is that RR preempts while FIFO doesn’t. FIFO processes stay on until higher priority FIFO comes on or until that FIFO process finishes.2Anonymous Mouse1 month agoNew RR appends to end of sub-queue of same prorities, similar to FIFO.The default RR does not do this though, new processes can get added anywhere in the ptable. Do we need to make a seperate data structure to ensure that the new processes get appended towards the end only?Also where does RR pick up from once FIFO finished?0Richard Alexander Barrezueta1 month agoIt kinda depends on how you implement it. But the overall behavior should be there.Let’s say you only have RR processes, then a FIFO comes in. The current RR goes in the back of the line, even within equal priorities.Currently running: pid 0 (RR, priority 0)RR: pid 2 (priority 0) -> pid 1 (priority 0)Currently running: pid 3 (FIFO, priority 0)RR: pid 0 (priority 0) -> pid 2 (priority 0) -> pid 1 (priority 0)pid 3 finishes and exits.Currently running: pid 1 (RR, priority 0)RR: pid 0 (priority 0) -> pid 2 (priority 0)2
    