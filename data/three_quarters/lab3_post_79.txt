Question: 
    When to yieldThe design requirements say that we need to yield:When a new process becomes runnable, if it should run before the current process, your scheduler should immediately preempt the currently running process and schedule it (with one exception, in "Nit").Does this mean we wait until the end of the time quanta regardless of scheduling algorithm the current process is using before we preempt?lab3

    Student Answer: 
    

    Instructor Answer: 
    

    Followup Discussions:
    @470_f1Anonymous Calc4 weeks agoIf a thread callsthread_wait()to wait on itself (thread 3 callsthread_wait(3)), how can we return the pid on success? The provided method frees the user stack and exits without returning.Also, are we supposed to save the user stack so that we can free it inthread_wait()?0Anonymous Poet4 weeks agoYou don’t need to free the stack inthread_wait(), you can do it inthread_create()because that doesn’t need to return in the newly created thread.I’m fairly certain a thread callingthread_wait()on itself is undefined behavior? Would appreciate if a TA could confirm though.0Anonymous Calc4 weeks agoWe would want the new thread to runstart_routineso we wouldn't want to exit the newly created thread though. I'm not sure what I'm missing but it seems that I can just usefree()instead offree_stack_and_exit()?Lab 8's slides also mentioned that:Calling fork or exec on a thread is undefinedSo does this mean we're not supposed to useexec()to runstart_routine?And from P3 Nit:Sincethread_waittakes in a pid, users can pass in the pid of the process itself (and not that of a thread created by it). This is fine.^I assumed this means that we should handle the case of a thread callingthread_wait() on itself.+1 It would be really helpful if any TA could clarify.0Anonymous Poet4 weeks agostart_routineis a function pointer… how were you planning to useexecto run it? You should just be callingstart_routineas a function with parameterarg. Afterstart_routinereturns, you can free the stack (all of this can happen inthread_create).~ An instructor (Rohan Natansh Bafna) thinks this is a good comment ~1Anonymous Calc4 weeks agoI’ve completely misunderstood how I should call start_routine. Thanks for catching that!0Rohan Natansh Bafna4 weeks agoRegarding callingthread_wait()on yourself, it’s best if you just return -1. I would avoid letting that be UB.good comment4Anonymous Poet4 weeks agoThat makes sense, I think if you’re usingwaitpidthis will be handled automatically anyway.~ An instructor (Rohan Natansh Bafna) thinks this is a good comment ~1Yirou Wang4 weeks agoIn the “Nits” section forthread_wait, it mentions thatSincethread_waittakes in a pid, users can pass in the pid of the process itself (and not that of a thread created by it). This is fine.Does this just mean we should return -1? Because it sounds like it’s allowing the pid of the process itself to execute without error.0@470_f2Anonymous Beaker4 weeks agoFor the default size would it just be KSTACKSIZE?0
    