Question: 
    Practice Exam Q6aOther than the possibility of p getting initializing twice (thus is no longer a singleton), I was think it would be possible that when one thread is in the critical section and have called malloc on p but have yet to finish initializing p, another thread would incorrectly assume that p has been initialized (the first if-statement returns false) and then attempts to use the uninitialized p outside of the shown piece of code. Would this be an acceptable answer?midterm

    Student Answer: 
    

    Instructor Answer: 
    The slides from Lecture 15 (Networking) might help clarify this situation. Here are some relevant screenshots. First, here’s what things look like when we use the interrupt driven model (Slide 22):The above screenshot shows this “Host-Network Gap” that demonstrates how we need to use syscalls and callbacks to access the network from user space given an interrupt-driven model.Slide 23 shows what happens when a user space application wants to read from the network. The network interface card (NIC) places packets into the ring buffer, and when the packets need to be processed the NIC raises an interrupt that gets handled by its device driver. That device driver will copy data from NIC memory into system memory, and then the user space app can access it via a read() syscall:The design above might not be so bad if we had a decent sized buffer and a normal amount of network traffic. However, if we imagine a situation where the NIC is very busy (such as in the network security appliance example), we’re going to be overwhelmed with interrupts and on top of that all the boundary crossings we have to do slow things down even further.So instead of using interrupts, we could opt to poll the NIC from userspace and avoid all this overhead. Typically the way this works is that the driver offers some interface for talking to the NIC directly from a privileged user space program, and a library that lets applications interact with that program. This is illustrated in Slide 24 (shown below). Basically this slide is showing that the userspace thread can call “epoll_wait()” to be notified when network traffic that it’s interested in has become available. Meanwhile the Poll Mode Driver is constantly checking on that NIC buffer for new packets. This constant checking is what eats up a lot of CPU, but the tradeoff is that we no longer have to be burdened by interrupts (and the expensive boundary crossings they introduce).

    Followup Discussions:
    @371_f1Varoon Sai Kodithala1 month agoThis was really helpful, thank you!0
    