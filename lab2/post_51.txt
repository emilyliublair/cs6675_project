Question: 
    

    Student Answer: 
    I don't think this is a page fault, it looks to me that your trap handler killed init somehow. Please check if there are unhandled cases in trap.c that led to you unintentionally killing a user process. Let me know how that goes!

    Instructor Answer: 
    

    Followup Discussions:
    @247_f1Shourik Banerjee1 month agoI don't know if it's trap.c, but if I switch back to the default allocuvm.c implementation it is able to boot properly. So I think the issue is either with how I handle a special flag for the zero page called PTE_ZERO which I set for it, and unset when it gets copied (so only page number 57210, my zero page has this flag), or it's in how I allocuvm.0Tianyi Yu1 month agoWhy would you unset PTE_ZERO when it gets copied? Wouldn't you only unset the Copy-on-write reference? I think you would only want to unset PTE_ZERO if you're allocating a new page for a zero page that was written to. It should be a different criterion from getting forked.0Shourik Banerjee1 month agoSorry, that's what I meant. When the new page gets created for it (so when it is written to), that's when PTE_ZERO gets unset.0Tianyi Yu1 month agoDid you flush the TLB entry after that Trap error 7, va = 0xff? It seems that right now your 0xff is still unmapped (error code 0->not present)0Shourik Banerjee1 month agoYes, in my handler after every page fault I flush the TLB using the address given to me by rcr2()0Tianyi Yu1 month agoCheck if you’re updating the PTE correctly since it’s definitely not getting reflected in the user process. Error code 0 means the page is unmapped, so check if the permissions you gave for the new page is correct. Make sure that the PTE_P is turned on.0Shourik Banerjee1 month agoUsing GDB, I found that even when I got a trap of 0, the permissions were that of a 0 page. The page num is also that of the zero page. The zero bit is on, and it is mapped. I have no idea where this is getting changed, especially considering that 0 means the page should be unmapped but the pte I get says it is mapped? I am confident that the pte I am getting is correct too considering I use walkpgdir to get the pte from the faulting virtual address.0Tianyi Yu1 month agoMaybe you aren’t dereferencing the pte pointer when changing the permission? You should be changing *pte and not pte. (just a guess)0Shourik Banerjee1 month agoUnfortunately not the case, thanks for trying help though. I'll see if I can get it resolved in OH tomorrow.1@247_f2Shourik Banerjee1 month agoI figured it out. Turns out, you're not supposed to lazy zero the code and data part with allocuvm.2Tianyi Yu1 month agoThat's great! Just a hint, you're not supposed to do that with the stack page either.0Shourik Banerjee1 month agoYeah I saw that in another Piazza post, just mentioned the data part because that was the part that was breaking it while I'm pretty sure the stack page just makes it less efficient.1
    