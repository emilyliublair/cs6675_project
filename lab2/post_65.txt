Question: 
    Testing hints?I'm really stuck on testing and I have tried to play around with user test cases and I haven't been able to break my kernel. However, I still have 4 cases in the autograder that are hard faulting.Here are some things I have tried:Killing the parent before the child (child retains pages but becomes a zombie)sbrking until fail (should get all memory below KERNBASE, but kallocing may fail if actually trying to write to these pages)testing writing to memory works on both parent and child processestesting syscalls like read() or pipe() worksforking until failI am lost on what I can test next. Can someone point me to what I'm missing?lab2

    Student Answer: 
    

    Instructor Answer: 
    Think about the last bullet point.

    Followup Discussions:
    @222_f1Anonymous Helix2 months agoDid you find any specific test cases that ended up helping? Curentlly I am failing cases 2-4 and 6-8 on AG. I ran all the tests in usertests.c and all of them work except mem() and preempt() (which is the expected behaviour).0@222_f2Andrew Boeger1 month agoCould you elaborate on the last bullet point? Just glancing at the xv6 user functions, there are about 100 ways to break things maliciously already. There's already unsafe strcopy, printf, and all sorts of stuff just sitting there for the user to exploit with - What do we need to consider "malicious" from the perspective of the user?0Alexa Suzanne Fazio1 month agoYes, but those things are not a consequence of your copy-on-write / lazy zero page allocation implementation.Think about ways that xv6 already provides security / isolation. Does your implementation ensure that those security features are still in-place?Think about how a user could corrupt the mechanisms within your implementation. Make sure that you prevent this.good comment1@222_f3Anonymous Beaker1 month agoI am still getting incorrect outputs for test cases 2-4 and 6-8. I am getting the correct output for ./forktest-xv6-qemu and have tested everything mentioned in this post + passed usertests.c.I've handled edge cases like:- killing the process for invalid access (all access to kernel space, user accessing kernel only pages, read/non-present page faults, writing to read only pages)- eagerly allocating pages that will soon be written toOne thing that I'm not sure of is handling syscalls where the kernel will access userspace on behalf of a user process - I'm sure that read() is one, and maybe file related ones are, but I am not sure.I wonder if there are any pointers as to what I may have missed. I've been stuck at this state for 3 days without any progress.1Anonymous Poet1 month agoAre you handling writes to guard page differently than other zero init pages? You might end up giving permission to write to the guard page after a page fault is triggered.0
    