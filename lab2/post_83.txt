Question: 
    Why do we ever need to call lab2_pagezero more than once?From forktest_expected_complete.out:!TESTSTART!PGTRAP: err: 0x7, va = 0x2fc4PGCOPY: 0x2000PGTRAP: err: 0x7, va = 0x2fc4PGZERO: 0x0PGZERO: 0x2000Since all virtual zeroed pages should point to the exact same physical page, why is PGZERO being called twice here? Would it not just call PGZERO once and have both virtual pages point to the one physical page that was zeroed?lab2

    Student Answer: 
    

    Instructor Answer: 
    What happens when you need to write to a zero page?

    Followup Discussions:
    @196_f1Anonymous Comp2 months agoWhen you write to a zero page, would it not just call lab2_pagecopy to copy all the zeros over from the zero page?1Rohan Natansh Bafna2 months agoThat works, but if we know that the bytes we are writing are all 0s, why waste time reading all the 0s from the zero page? It would be faster to use lab2_pgzero instead.good comment1Anonymous Comp2 months agoAh that makes sense, thanks0Anonymous Comp2 months agoOk I actually have another question about this. In the expected output we observe zeroing two pages in a row, but if we're writing to the zero page does that not first require a page fault?0Rohan Natansh Bafna2 months agoNot always. If it’s the user writing to a page, then yes, it requires a page fault because we need to enter kernel space to do the copy, but if it’s the kernel writing to a page, that may not be necessary, since we are already in kernel space.good comment0Anonymous Comp2 months agoHmm, I've been thinking about it and I'm really not sure when we would ever need to write to a user page. I assume that doesn't include page zeroing and page copies.0Anonymous Comp2 months agoIs it in exec() when the kernel has to write the user program's arguments to its stack?0Rohan Natansh Bafna2 months agoNo, in exec we create a new page directory and only switch to it after the new process is totally set up, meaning that the arguments are written to the corresponding physical address. Exec calls copyout to do this.You saw a few syscalls in lab 0 that wrote to the user process’s memory. Check their source code, see how they do so!good comment0Anonymous Comp2 months agoThe only syscall I can think of that writes to a process' memory is write() when writing to a pipe. Are there more?On a side note, are we also expected to lazily zero the pages allocated in exec()? The pdf only mentions lazily allocating in sbrk, but are there other instances where a process will gain memory which we need to lazily zero?0Rohan Natansh Bafna2 months agoWriting to a pipe does NOT write to userspace, because the pipe buffer is stored in the kernel’s memory as part of the pipe struct! (See pipe.c)Are there any other syscalls where you, say, pass an address to the kernel where it can return some data?Try to lazy-zero allocate as much as you can (so that includes what’s allocated in exec()), but keep in mind that if you know that you are going to write to a newly mapped page, you should avoid page faulting and instead eagerly allocate the physical page, since every interrupt costs some time.good comment0Anonymous Gear2 months agoSo would we be modifying a lot of individual system calls in this case? Why would a program try to write all 0s when a newly allocated page is already zeroed out.You mentioned exec() but exec uses allocuvm underneath to zero the pages, so I don’t think it would need direct changes.Also how can you tell in advance what you are going to write to a newly mapped page immediately or if you will write all zeroes.0Rohan Natansh Bafna2 months agoSo would we be modifying a lot of individual system calls in this case?Not necessarily; it depends on your design. You recognize that exec() uses a different function to write to the process’s memory; that may be true for other syscalls too.Why would a program try to write all 0s when a newly allocated page is already zeroed out.I don’t understand your question. A program doesn’t usually write all 0s to a block of memory.What I was saying earlier was that if a program writes to the zero page, or the kernel writes to the zero page on behalf of the program, then we’d need to perform a copy so that the zero page doesn’t get overwritten with data.Also how can you tell in advance what you are going to write to a newly mapped page immediately or if you will write all zeroes.Context. If I allocate a page for the user, map it, and then immediately write to it, then I probably would want to eagerly allocate the page instead of lazily allocating it. It’s situation dependent.good comment1
    