Question: 
    Part 1, test case 6 and 9I'm failing these two test cases, does anyone know what the potential issue could be?lab3

    Student Answer: 
    

    Instructor Answer: 
    

    Followup Discussions:
    @374_f1Richard Alexander Barrezueta4 weeks agoI think 9 has to do with when you lower the current running process’ priority, whether it preempts to another process that now has a higher priority to it.0Anonymous Mouse4 weeks agoweird, if all the processes in the ptable are RR, wouldnt this cause the currently executing process to be stopped in favor of the next in line for RR?0Varoon Sai Kodithala4 weeks agoWell, it depends on their priorities. If we just lowered the priority of a process and there's a process with a higher priority with the RUNNABLE flag set in the ptable, then we should schedule that process. If there's no process with a strictly greater priority in the ptable, then we continue on with our current process.0Anonymous Mouse4 weeks agoDosent RR always wana schedule next next process on a yield() though?0Richard Alexander Barrezueta4 weeks agoAlso you only consider RR if equal highest priorities (and assuming there are no FIFO. FIFO always have higher priority than any RR).So schedule based on priority first, then policy if equal priorities.0Anonymous Calc4 weeks agoSo schedule based on priority first, then policy if equal priorities.Wait, what do you mean by this? I thought FIFO will always get scheduled before RR?0Anonymous Mouse4 weeks agoLets say that you have a bunch of processes which are all RR and an index which keeps track of the current RR process running.Then, far away from the index, a process turns into FIFO and takes control. Where does the RR pick up from? Does it continue from the new spot or does it fall back to where it used to be?1Anonymous Calc4 weeks agoohh ok i see what you mean, thank you0Richard Alexander Barrezueta4 weeks agoHere’s some examples, since it’s kinda hard to explain without:FIFO priority 1 > RR priority 50FIFO priority 2 > FIFO priority 1RR priority 1 (arrived first) > RR priority 1 (arrived later)FIFO priority 1 (arrived first) > FIFO priority 1 (arrived later)New RR appends to end of sub-queue of same prorities, similar to FIFO.The only difference between RR and FIFO is that RR preempts while FIFO doesn’t. FIFO processes stay on until higher priority FIFO comes on or until that FIFO process finishes.2Anonymous Mouse4 weeks agoNew RR appends to end of sub-queue of same prorities, similar to FIFO.The default RR does not do this though, new processes can get added anywhere in the ptable. Do we need to make a seperate data structure to ensure that the new processes get appended towards the end only?Also where does RR pick up from once FIFO finished?0Richard Alexander Barrezueta4 weeks agoIt kinda depends on how you implement it. But the overall behavior should be there.Let’s say you only have RR processes, then a FIFO comes in. The current RR goes in the back of the line, even within equal priorities.Currently running: pid 0 (RR, priority 0)RR: pid 2 (priority 0) -> pid 1 (priority 0)Currently running: pid 3 (FIFO, priority 0)RR: pid 0 (priority 0) -> pid 2 (priority 0) -> pid 1 (priority 0)pid 3 finishes and exits.Currently running: pid 1 (RR, priority 0)RR: pid 0 (priority 0) -> pid 2 (priority 0)2
    